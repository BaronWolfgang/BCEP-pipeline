#!/usr/bin/perl

use Getopt::Std;
use Cwd;

###############################################################################
#               GENERAL SETTINGS: CUSTOMIZE TO YOUR SITE
###############################################################################

BEGIN {

  # full path to the netsurfp-1.0 directory (mandatory)
  $ENV{NetSurfP}	= '/hpc/dla_lti/jvanmeenen/mrp/BCEP-pipeline/src/netsurfp-1.0';
  
  # full path to the 'blastpgp' executable on your system
  $ENV{BLASTPROG}	= '/hpc/dla_lti/jvanmeenen/miniconda3/envs/BCEP/bin/blastpgp';
  #$ENV{BLASTPROG}	= '/usr/cbs/bio/bin/irix64/blastpgp';

  # full path to the BLAST data directory on your system
  $ENV{BLASTMAT}	= '/usr/cbs/bio/src/blast-2.2.18/data/';

  # determine where to store temporary files (must be writable to all users)
  $ENV{TMPDIR}		= '/hpc/dla_lti/jvanmeenen/mrp/BCEP-pipeline/src/bp2/netsurfp-1.0/tmp/';

}

# full path to the BLAST database to use (see installation instructions) 
my $db = "$ENV{NetSurfP}/nr70_db/nr70";
# NOTE:	you do not need not change this setting if you are using the NR70 db
# 	mentioned in the installation instructions, point 3.

# number of chunks that the BLAST database is composed of
my $chunks = 5;

###############################################################################
#               NOTHING SHOULD NEED CHANGING BELOW THIS LINE!
###############################################################################

#
# Default values
#
my $TYPE="FASTA";

$ENV{UNIX} = `uname -s`;
$ENV{ARCH} = `uname -m`;
chomp $ENV{UNIX};
chomp $ENV{ARCH};

use lib "$ENV{NetSurfP}/modules";
use FASTA;
use HOW;
use PROF;
use ACT;

use strict;

# NetSurfP synapse files
my $netsurfp_seq2struc = "$ENV{NetSurfP}/data/seq2struc.synlist";

my $netsurfp_struc2struc_dir = "$ENV{NetSurfP}/data/struc2struc";

# Secondary structure synapse files
my $sec_seq2struc = "$ENV{NetSurfP}/data/sec_seq2struc.synlist";
my $sec_struc2struc = "$ENV{NetSurfP}/data/sec_struc2struc.synlist";

#
# Window sizes used by the NetSurfP Neural Networks
#
my @windows=qw(11);

#
# Process command line
#
getopts('hi:j:J:o:t:T:kvad:')||Usage();
#
# Usage
#
if (defined($Getopt::Std::opt_h)||defined($Getopt::Std::opt_h)){
  # Print help message
  Usage();
}

sub Usage {
  print ("Usage: $0 [-h] [-i name] [-o name] [-t type] [-s how_syn_dir] [-j sec_pred_input_file] [-J sec_pred_output_file] [-v] [-k] [-a] [-d database]\n");
  print ("Description:\n");
  print ("$0 - Predict surface accessibility and secondary structure of proteins\n");
  print ("\n");
  print ("Options:\n");
  print ("  -h  : display this message\n");
  print ("  -i  : input file name [STDIN]\n");
  print ("  -j  : input secondary structure pred file name\n");
  print ("  -t  : input type \([$TYPE]|PROF|HOW\)\n");
  print ("  -o  : output rsa file-name [STDOUT]\n");
  print ("  -J  : output sec file-name\n");
  print ("  -a  : additional sec output in same output as rsa output [off]\n");
  print ("  -d  : nr blast database [$db]\n");
  print ("  -s  : synapse netsurfp_struc2struc_dir directory [$netsurfp_struc2struc_dir]\n");
  print ("  -k  : keep all temp directories [off]\n");
  print ("  -T  : Use this temporary directory [off]\n");
  print ("  -v  : Verbose mode [off]\n");
  print ("\n");
 exit;
} # Usage

#
# Open input
#
if (not defined($Getopt::Std::opt_i)){
  # Read from standard input
  *INP = *STDIN;
} 
else{
  # Read from file
  if (($Getopt::Std::opt_i=~/\.gz$/) || ($Getopt::Std::opt_i=~/\.Z$/)){
    open(INP,"gunzip -c $Getopt::Std::opt_i |") || die ("can't open file $Getopt::Std::opt_i: $!");
  }
  else{
    open(INP,"<$Getopt::Std::opt_i") || die ("can't open file $Getopt::Std::opt_i: $!");
  }
}
#
# If not file name is given, use standard output
#
if (not defined($Getopt::Std::opt_o)){
  # Output goes to std output
  *OUT = *STDOUT;
} else {
  # Open file to write to
  open(OUT, ">$Getopt::Std::opt_o") || die ("can't open file $Getopt::Std::opt_o: $!");
}

if (defined($Getopt::Std::opt_t)){
    $TYPE=$Getopt::Std::opt_t;
    if ($TYPE ne 'PROF' && $TYPE ne 'HOW' && $TYPE ne 'FASTA'){
	print STDERR ("# Unknown input data type\n");
	print STDERR ("# Valid types are: PROF, HOW and FASTA\n");
	exit;
    }
}
if (defined($Getopt::Std::opt_d)){
  $db=$Getopt::Std::opt_d;
}
my $tmpdir;
if (defined($Getopt::Std::opt_T)){
  $tmpdir=$Getopt::Std::opt_T;
}


##############################################################################
# Main
#
###############################################################################
#
# Programs used
#

#Exit and print error, if BLAST database can not be found
my $blastfiles = `ls -1 $db.* 2>/dev/null | wc -l`;
unless ( "$blastfiles" ){
print STDERR "\nERROR!\nThe BLAST database path is set to $db, but can not be located.\nPlease control that the setting for \$db is correct.\n\n";
exit;
}

#Exit and print error, if blastpgp executable can not be found
unless (-e $ENV{BLASTPROG}) {
print STDERR "\nERROR!\nThe full path to the 'blastpgp' executable on your system is set to $ENV{BLASTPROG}, but can not be located.\nPlease control that the setting for \$ENV{BLASTPROG} is correct.\n\n";
exit;
}

#Exit and print error, if BLAST data directory can not be found
unless (-e $ENV{BLASTMAT}) {
print STDERR "\nERROR!\nThe full path to the BLAST data directory on your system is set to $ENV{BLASTMAT}, but can not be located.\nPlease control that the setting for \$ENV{BLASTMAT} is correct.\n\n";
exit;
}

my $nnrelia_player = "$ENV{NetSurfP}/bin/nnrelia_player4."."$ENV{UNIX}"."\_$ENV{ARCH}";
my $number2win     = "$ENV{NetSurfP}/scripts/number2win.pl";
my $nnlinplayer    = "$ENV{NetSurfP}/bin/nnlinplayer."."$ENV{UNIX}"."\_$ENV{ARCH}";
my $makeprof       = "$ENV{NetSurfP}/scripts/make_prof.pl";
my $nnhowplayer    = "$ENV{NetSurfP}/bin/nnhowplayer6."."$ENV{UNIX}"."\_$ENV{ARCH}";
my $act2prob       = "$ENV{NetSurfP}/bin/act2prob."."$ENV{UNIX}"."\_$ENV{ARCH}";
my $ave_probmat    = "$ENV{NetSurfP}/bin/ave_probmat."."$ENV{UNIX}"."\_$ENV{ARCH}";
my $ave_probmat_norm    = "$ENV{NetSurfP}/data/ave_probmat_norm";

#
# Make a temp working directory
#
if (!defined($Getopt::Std::opt_T)) {
$tmpdir= "$ENV{TMPDIR}/NetSurfP_$$";
}
if (! -d "$tmpdir") {
system("mkdir -m 0777 -p $tmpdir");
}

if (defined($Getopt::Std::opt_v)){
    print STDERR ("\n# Made temp dir: $tmpdir\n");
}
#
# maximum surface acessible area for Ala-X-Ala
#
my %ASA={};
$ASA{A}=110.2;
$ASA{C}=140.4;
$ASA{D}=144.1;
$ASA{E}=174.7;
$ASA{F}=200.7;
$ASA{G}=78.7;
$ASA{H}=181.9;
$ASA{I}=185.0;
$ASA{K}=205.7;
$ASA{L}=183.1;
$ASA{M}=200.1;
$ASA{N}=146.4;
$ASA{P}=141.9;
$ASA{Q}=178.6;
$ASA{R}=229.0;
$ASA{S}=117.2;
$ASA{T}=138.7;
$ASA{V}=153.7;
$ASA{W}=240.5;
$ASA{Y}=213.7;
$ASA{B}=176.7;
$ASA{Z}=145.3;


#
# Make a .ncbirc file
#
my $cmd="cp $ENV{NetSurfP}/etc/.ncbirc $tmpdir";
system("$cmd");

my $orig_dir=cwd;
my $input_file="$tmpdir/file.inp";
my $log  = "$tmpdir/file.log";
my $prof = "$tmpdir/file.prof";
my $sec;
if (defined($Getopt::Std::opt_j)){
    $sec=$Getopt::Std::opt_j;
    system("cp $sec $tmpdir/file.sec");
}
else{
    $sec="$tmpdir/file.sec";
}

my $netsurfp_1 = "$tmpdir/netsurfp_seq2struc.out";
$cmd;
open(FILE,">$input_file");
while (! eof (INP)){
    $_=<INP>;
    print FILE ("$_");
}
close(FILE);
close(INP);

#
# Make profile if input is HOW or FASTA
#
if ($TYPE ne 'PROF'){

    $cmd = "$makeprof -i $input_file -I $TYPE -o $prof -L $log -a $chunks -v -e 1e-05 -d $db -j 4 -t $tmpdir -k";
 
    if (defined($Getopt::Std::opt_v)){
	print STDERR ("# executing: $cmd\n");
    }
    chdir $tmpdir;
  
     
    exit if system("$cmd");     
       
    chdir $orig_dir;
}else{
    $prof=$input_file;
}


if (! defined($Getopt::Std::opt_j)){
  #
  # Make secondary structure predictions
  #
    $cmd = "$nnhowplayer -p $prof -slist -s x $sec_seq2struc | grep -v \"^#\" | $nnhowplayer -a -- -slist -pc -s x $sec_struc2struc | grep -v \"^#\" | $act2prob  -- $ave_probmat_norm | grep -v \"^#\" > $sec";
    if (defined($Getopt::Std::opt_v)){
	print STDERR ("# executing: $cmd\n");
    }
    system("$cmd");
}


#
# Make sequence to structure predictions eg 1. networks
#
$cmd = "$nnhowplayer -p $prof -a $sec -slist -s x $netsurfp_seq2struc | grep -v \"^#\" > $netsurfp_1";
if (defined($Getopt::Std::opt_v)){
    print STDERR ("# executing: $cmd\n");
}
system("$cmd");


#
# 
#
my $rsa;
my $rsa_relia;
my $synlist;
my $i;

foreach my $win (@windows){
    #
    # Make input to nnlinplayer
    #
    $rsa="$tmpdir/rsa.$win";
    $rsa_relia="$tmpdir/rsa_relia.$win";
    $cmd="$number2win -i $prof -j $netsurfp_1 -w $win -o $tmpdir/prof_inp.$win";
    if (defined($Getopt::Std::opt_v)){
	print STDERR ("# executing: $cmd\n");
    }
    system("$cmd\n");
    # $synlist= "$netsurfp_struc2struc_dir/synlist.A-J.$win";
    $synlist= "$netsurfp_struc2struc_dir/synlist_best.A-J.NW11";

    $cmd="$nnrelia_player -zf $synlist $tmpdir/prof_inp.$win | grep -v \"^\#\" | cut -f3 -d \" \" > $rsa";
    if (defined($Getopt::Std::opt_v)){
	print STDERR ("# executing: $cmd\n");
    }
    system("$cmd");
    $cmd="$nnrelia_player -zf $synlist $tmpdir/prof_inp.$win | grep -v \"^\#\" | cut -f9 -d \" \" > $rsa_relia";
    if (defined($Getopt::Std::opt_v)){
	print STDERR ("# executing: $cmd\n");
    }
    system("$cmd");
}
#
# Make file with average rsa predictions
#
$cmd="paste ";
foreach my $win (@windows){
    $cmd .= "$tmpdir/rsa.$win ";
}
$cmd .= '| awk \'{ sum=0;for ( i=1 ; i<=NF ; i=i+1 ) sum = sum + $i}; { printf ("%6.4f\n",sum/NF) }\'';
$cmd .= " > $tmpdir/ave.rsa";
system("$cmd");

#
# Make file with averge reliability
#
$cmd="paste ";
foreach my $win (@windows){
    $cmd .= "$tmpdir/rsa_relia.$win ";
}
$cmd .= '| awk \'{ sum=0;for ( i=1 ; i<=NF ; i=i+1 ) sum = sum + $i}; { printf ("%6.4f\n",sum/NF) }\'';
$cmd .= " > $tmpdir/ave_relia.rsa";
system("$cmd");

#
# Make file with average rsa + rsa for each network before averaging
#
$cmd="paste $tmpdir/ave.rsa ";
foreach my $win (@windows){
    $cmd .= "$tmpdir/rsa.$win ";
}
$cmd .= ">$tmpdir/rsa.all";
system("$cmd");

#
# Make file with average reliability + reliability for each network before averaging
#
$cmd="paste $tmpdir/ave_relia.rsa ";
foreach my $win (@windows){
    $cmd .= "$tmpdir/rsa_relia.$win ";
}
$cmd .= ">$tmpdir/rsa_relia.all";
system("$cmd");

#
# Make the final output with average rsa (column 1) and average reliability (column 2)
#
$cmd="paste $tmpdir/ave.rsa $tmpdir/ave_relia.rsa > $tmpdir/rsa.final";
system("$cmd");

open(ALL,"<$tmpdir/rsa.final");
open(PROF,"<$prof");
#
# Should secondary structure predictions be added as extra columns to output ?
#
if (defined($Getopt::Std::opt_a)){
  open(SEC,"<$tmpdir/file.sec");
}
print OUT ("# Column 1: Class assignment - B for buried or E for Exposed - Threshold: 25% exposure, based on 1.st layer networks and not based on RSA\n");
print OUT ("# Column 2: Amino acid\n");
print OUT ("# Column 3: Sequence name\n");
print OUT ("# Column 4: Amino acid number\n");
print OUT ("# Column 5: Relative Surface Accessibility - RSA\n");
print OUT ("# Column 6: Absolute Surface Accessibility\n");    
print OUT ("# Column 7: Z-fit score\n");    
if (defined($Getopt::Std::opt_a)){
    print OUT ("# Column 8: Probability for Alpha-Helix\n");
    print OUT ("# Column 9: Probability for Beta-strand\n");
    print OUT ("# Column 10: Probability for Coil\n");    
}
open(CLASS,"<$netsurfp_1") || die ("Can't open file: $netsurfp_1\n");
while (! eof (ALL)){
    while (! eof (PROF)){
	my %r={};
	my %rec={};
	my $j=1;
	%r=readPROF(\*PROF);
	
	$rec{name}=$r{name};
	$rec{len}=$r{len};
	for (my $j=1;$j<=$rec{len};$j++){
	    my $class_assignment = <CLASS>;
	    chomp($class_assignment);;
	    my @w = ();
	    @w=split(/\s+/,$class_assignment);
	    if ($w[-1] >= $w[-2]){
		$rec{sec}[$j]='E';		
	    }
	    else{
		$rec{sec}[$j]='B';				
	    }
	    $_=<ALL>;
	    chomp;
	    @w=();
	    @w=split(/\s+/,$_);
	    $rec{seq}[$j]=$r{seq}[$j];
	    $rec{resnum}[$j]=$r{resnum}[$j];
	    #
	    # The average value
	    #
	    my $acid = uc($rec{seq}[$j]);
    
	    if (! defined($ASA{$acid})){
       	    $rec{sec}[$j]=' ';				
	    $rec{act}[$j][1] = 0;
	    $rec{act}[$j][2] = 0;
            $rec{act}[$j][3] = 0;
	    
	    }
	    else {
	    $rec{act}[$j][1]=$w[0];
	    $rec{act}[$j][2]=$rec{act}[$j][1]*$ASA{$acid};
	    $rec{act}[$j][3]=$w[1];

	  }
	    if (defined($Getopt::Std::opt_a)){
	        $_=<SEC>;
	        chomp;
	        my @w=();
	        @w=split(/\s+/,$_);
		
	     if (! defined($ASA{$acid})){
           	 $rec{act}[$j][4] = 0;
         	   $rec{act}[$j][5] = 0;
         	   $rec{act}[$j][6] = 0;

		}
	     else{		
	        $rec{act}[$j][4] = $w[-3];
	        $rec{act}[$j][5] = $w[-2];
	        $rec{act}[$j][6] = $w[-1];
	    }
	    
	    
	    }
	}
	writeACT(\%rec,\*OUT);
    }
}
close(ALL);
close(PROF);
close(CLASS);
if (defined($Getopt::Std::opt_a)){
  close(SEC);
}
if (defined($Getopt::Std::opt_J)){
  open(SEC,"<$tmpdir/file.sec");
  open(SECOUT,">>$Getopt::Std::opt_J");
  my %rec={};
  while (! eof (SEC)){
    %rec=readACT(\*SEC);
    writeACT(\%rec,\*SECOUT);
  }
  close(SECOUT);
  close(SEC);
#    system("cp $tmpdir/file.sec $Getopt::Std::opt_J");
}
if (! defined($Getopt::Std::opt_k)){
    system("rm -rf $tmpdir");
}
